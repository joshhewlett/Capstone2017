<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="/socket.io/socket.io.js"></script>

    <style>
    body {
        background-color: rgb(240, 240, 240);
    }

    </style>
    <title>Socket.IO Test</title>
</head>

<body>

    <h1>Socket.IO Test Page</h1>

    <!-- Event emitters -->

    <div>
        <h3>Emitters (Hololens Client)</h3>
        <p id="emitError" style="width: 100%; visibility:hidden;">
            <strong style="color:red;">Error: </strong>
            <span id="errorMsg"></span>
            <button onclick=" clearError(); ">Clear error</button>
        </p>

        <div>
            <h3 style="color:dimgray">Data information:</h3>
            <span>Choose presentation id:</span>
            <input id="mainPresentation_id" type="number" style="width: 100px; " placeholder="presentation id" onkeyup="getPresentationSlides(this)">


            <div style="display: inline-block;">
                <span>Presentation slides:
                    <ul name="mainSlideIds" id="mainSlideIds" style="display: inline"></ul>
                </span>
            </div>

            <div style="display: inline-block;">
                <span>Slide models:
                    <ul name="slideModelIds" id="slideModelIds" style="display: inline"></ul>
                </span>
            </div>

            <br>
            <p>Current slide id: <span id="slideIdIndicator"></span> </p>
        </div>

        <hr>
        <h3 style="color:blue ">--- transform_update ---</h3>

        <div id="updateDiv" style="width: 100%; display: block;">

            <p style="width:100%;">
                Choose model id:
                <input id="emitUpdate_modelId" type="number " style="width: 50px; " placeholder="model id ">

                <br>
                <p style="display: inline;">
                    <strong style="font-size: 25px; ">Manual</strong>
                    <br>
                    <span>Position:&nbsp;</span>
                    <input id="emitUpdate_transform_posX " type="text " style="width: 30px; " placeholder="X pos ">
                    <input id="emitUpdate_transform_posY " type="text " style="width: 30px; " placeholder="Y pos ">
                    <input id="emitUpdate_transform_posZ " type="text " style="width: 30px; " placeholder="Z pos ">
                    <br>
                    <span>Rotation:&nbsp;</span>
                    <input id="emitUpdate_transform_rotX " type="text " style="width: 30px; " placeholder="X rot ">
                    <input id="emitUpdate_transform_rotY " type="text " style="width: 30px; " placeholder="Y rot ">
                    <input id="emitUpdate_transform_rotZ " type="text " style="width: 30px; " placeholder="Z rot ">
                    <br>
                    <span>Scale:&nbsp;</span>
                    <input id="emitUpdate_transform_scale " type="text " style="width: 30px; " placeholder="Scale ">
                    <button onclick="manualUpdate();">Emit 'update'</button>
                    <button onclick="resetToOrigin();">Reset object to origin</button>
                </p>

                <p style="display: inline;">
                    <strong style="font-size: 25px; ">Automatic</strong>
                    <br>
                    <!-- Animation style -->
                    <label for="smoothAnim">Smooth:</label>
                    <input type="radio" id="smoothAnim" name="animationStyle" value="smooth">

                    <label for="randomAnim">&nbsp;&nbsp;Random: </label>
                    <input type="radio" id="randomAnim" name="animationStyle" value="random">

                    <!-- Position, Rotation, Scale options -->
                    <br>
                    <label for="positionCB">Position:</label>
                    <input id="positionCB" name="positionCB" type="checkbox">
                    <label for="rotationCB">&nbsp;Rotation:</label>
                    <input id="rotationCB" name="rotationCB" type="checkbox">
                    <label for="scaleCB">&nbsp;Scale:</label>
                    <input id="scaleCB" name="scaleCB" type="checkbox">
                    <br>

                    <!-- Step size -->
                    <label for="stepSize">Step size or max for random:</label>
                    <input id="stepSize" style="width:50px;" value="0.2" step="0.1" type="number">
                    <br>

                    <!-- Updates per second -->
                    <label for="updatesPerSecond">Updates per second:</label>
                    <input id="updatesPerSecond" style="width:50px;" value="60" type="number">
                    <br>
                    <!-- Updates per second -->
                    <button id="automaticUpdatesSwitch" style="color:green;" onclick="startAutomaticUpdates();">Start automatic updates</button>
                </p>
                <br>

            </p>
            <br>


        </div>

        <!-- Start and End presentation -->
        <div id="startDiv" style="width:100%; display: block;">
            <h3 style="color:blue ">--- presentation_start and  presentation_end ---</h3>
            <p style="display: inline-block; width:100%;">
                <input type="button" value="Start presentation" onclick="startPresentation()">
                <input type="button" value="End presentation" onclick="endPresentation()">
            </p>
        </div>

        <!-- Slide Change -->
        <div id="slideChangeDiv" style="width:100%; display: block;">
            <h3 style="color:blue ">--- slide changed ---</h3>
            <p style="display: inline-block; width:100%;">
                Choose Slide id:
                <input id="emitSlide_changeId" type="number " style="width: 100px; " placeholder="slide id ">
                <input type="button" value="Change slide" onclick="slideChange()">
            </p>
        </div>

    </div>

    <script>
    // Connect to SocketIO
    var socket = io.connect('http://localhost:3000');
    socket.on('connect', function(data) {
        console.log(data);
    });

    // Automatic updates setup
    let updateIntervalSeconds = 17;
    var updateTimer;

    // Initialize modelId
    let modelId = document.getElementById("emitUpdate_modelId").value;

    // Values for x, y, z position, rotation and scale
    let xPos = 0;
    let yPos = 0;
    let zPos = 0;
    let xRot = 0;
    let yRot = 0;
    let zRot = 0;
    let scale = 1;

    // Values for step size and current step
    let stepSize = parseFloat(document.getElementById("stepSize").value);
    let currentStepVal = 0;
    let looper = stepSize;

    // Booleans indicating whether auto-update should be updating
    // respective transform property
    let updatePos, updateRot, updateScale = false;

    // Radio value for animation style
    let chosenRadio = null;

    /**
     * Main State control
     */
    let STATE = null;
    getPresentationSlides(document.getElementById("mainPresentation_id"));

    function getPresentationSlides(presId) {
        console.log(presId.value);
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                console.log(this.responseText);
                parseResponseData(this.responseText);
            }
        };
        let url = '/presentation/' + presId.value + '/all';
        xhttp.open("GET", url, true);
        xhttp.send();
    }

    function parseResponseData(data) {
        clearChildren(document.getElementById("mainSlideIds"));
        data = JSON.parse(data);

        console.log(data);
        STATE = data.presentation;

        let slideUL = document.getElementById("mainSlideIds");
        for (let slide of STATE.slides) {
            let newLI = document.createElement("li");
            let button = document.createElement("input");

            button.type = "button";
            button.value = slide.id;
            button.setAttribute("onclick", "getSlideModels(this);");

            newLI.style.marginRight = "2%";
            newLI.style.display = "inline";

            newLI.appendChild(button);
            slideUL.appendChild(newLI);
        }
        document.getElementById("slideIdIndicator").innerHTML = STATE.slides[0].id;
    }

    function getSlideModels(slideId) {
        clearChildren(document.getElementById("slideModelIds"));
        console.log(slideId);
        slideId = slideId.value;

        let slideObj = null;
        for (let slide of STATE.slides) {
            if (slide.id == slideId) {
                slideObj = slide;
                break;
            }
        }

        let modelUL = document.getElementById("slideModelIds");
        for (let model of slideObj.models) {
            let newLI = document.createElement("li");
            let button = document.createElement("input");

            button.type = "button";
            button.value = model.id;
            button.onclick = "getModel(this);";

            newLI.style.marginRight = "2%";
            newLI.style.display = "inline";

            newLI.appendChild(button);
            modelUL.appendChild(newLI);
        }
    }

    function clearChildren(htmlElement) {
        while (htmlElement.firstChild) {
            htmlElement.removeChild(htmlElement.firstChild);
        }
    }

    /*
     * ===== Automatic updating functions =====
     */

    // Start automatic updates
    function startAutomaticUpdates() {

        updateUserSettings();

        // Choose smooth or random updates
        if (chosenRadio == "smooth") {
            currentStepVal = 0;
            looper = stepSize;
            updateTimer = setInterval(function() {
                smoothAutoUpdates();
            }, updateIntervalSeconds);
        } else if (chosenRadio == "random") {
            updateTimer = setInterval(function() {
                randomAutoUpdates();
            }, updateIntervalSeconds);
        }

        // Update toggle button to give user option to stop updates
        let button = document.getElementById("automaticUpdatesSwitch");
        button.innerHTML = "Stop automatic updates";
        button.style.color = "red";
        button.setAttribute("onclick", "stopAutomaticUpdates();");

    }

    // Stop the automatic updates
    function stopAutomaticUpdates() {
        // Clear timer
        clearInterval(updateTimer);

        // Update toggle button to give user option to start updates
        let button = document.getElementById("automaticUpdatesSwitch");
        button.innerHTML = "Start automatic updates";
        button.style.color = "green";
        button.setAttribute("onclick", "startAutomaticUpdates();");
    }

    // Defines behavior of random updates
    function randomAutoUpdates() {
        updateUserSettings();

        // If settings are no longer random, stop animation
        if (chosenRadio != "random") {
            clearInterval(updateTimer);
            startAutomaticUpdates();
            return;
        }

        // Give random position according to settings
        if (updatePos) {
            xPos = Math.random() * stepSize;
            yPos = Math.random() * stepSize;
            zPos = Math.random() * stepSize;
        }
        if (updateRot) {
            xRot = Math.random() * stepSize;
            yRot = Math.random() * stepSize;
            zRot = Math.random() * stepSize;
        }
        if (updateScale) {
            scale = Math.random() * stepSize;
        }

        emitUpdate();
    }

    // Defines behavior of smooth animation updates
    function smoothAutoUpdates() {
        updateUserSettings();

        // If settings are no longer smooth, stop animation
        if (chosenRadio != "smooth") {
            clearInterval(updateTimer);
            startAutomaticUpdates();
            return;
        }
        // Incremenet current step to keep track of looping
        currentStepVal += looper;


        // If currentStepVal has reached max or min,
        // reverse loop
        if (currentStepVal <= -3 || currentStepVal >= 3) {
            looper *= -1;
        }

        // Incremement according to settings
        if (updatePos) {
            xPos += looper;
            yPos += looper;
            zPos += looper;
        }
        if (updateRot) {
            xRot += looper;
            yRot += looper;
            zRot += looper;
        }
        if (updateScale) {
            scale += looper;
        }

        emitUpdate();
    }

    /*
     * ===== Manual Update =====
     */

    function manualUpdate() {
        let modelId = document.getElementById("emitUpdate_modelId").value;
        if (!modelId) {
            emitError("Must provide model id");
            return;
        }

        xPos = document.getElementById("emitUpdate_transform_posX ").value == " " ? 0 : parseFloat(document.getElementById("emitUpdate_transform_posX ").value);
        yPos = document.getElementById("emitUpdate_transform_posY ").value == " " ? 0 : parseFloat(document.getElementById("emitUpdate_transform_posY ").value);
        zPos = document.getElementById("emitUpdate_transform_posZ ").value == " " ? 0 : parseFloat(document.getElementById("emitUpdate_transform_posZ ").value);

        xRot = document.getElementById("emitUpdate_transform_rotX ").value == " " ? 0 : parseFloat(document.getElementById("emitUpdate_transform_rotX ").value);
        yRot = document.getElementById("emitUpdate_transform_rotY ").value == " " ? 0 : parseFloat(document.getElementById("emitUpdate_transform_rotY ").value);
        zRot = document.getElementById("emitUpdate_transform_rotZ ").value == " " ? 0 : parseFloat(document.getElementById("emitUpdate_transform_rotZ ").value);

        scale = document.getElementById("emitUpdate_transform_scale ").value == " " ? 1 : parseFloat(document.getElementById("emitUpdate_transform_scale ").value);
        emitUpdate();
    }

    /*
     * ===== Convenience functions
     */

    // Resets given object to origin with scale 1
    function resetToOrigin() {
        xPos = 0;
        yPos = 0;
        zPos = 0;
        xRot = 0;
        yRot = 0;
        zRot = 0;
        scale = 1;

        modelId = document.getElementById("emitUpdate_modelId").value;

        emitUpdate();
    }

    // Assembles data and emits event to socket
    function emitUpdate() {

        // Assemble position object
        let position = {
            x: xPos,
            y: yPos,
            z: zPos
        }

        // Assemble rotation object
        let rotation = {
            x: xRot,
            y: yRot,
            z: zRot
        }

        // Assemble transform object
        let transform = {
            position,
            rotation,
            scale
        };

        // Prepare event payload
        // transform = JSON.stringify(transform);
        model = parseInt(document.getElementById("emitUpdate_modelId").value);
        let data = {
            model: model,
            position,
            rotation,
            scale
        }
        //data = JSON.stringify(data);

        // Emit socket event
        socket.emit('update', data);
    }

    // Updates automatic updates user settings
    function updateUserSettings() {
        // Get smooth or random
        var radios = document.getElementsByName('animationStyle');
        chosenRadio = null;
        for (var i = 0, length = radios.length; i < length; i++) {
            if (radios[i].checked) {
                chosenRadio = radios[i].value;
                break;
            }
        }

        // Error if neither are chosen
        if (!chosenRadio) {
            emitError("Must choose an animation style");
        }

        // Update transform property booleans
        updatePos = document.getElementById("positionCB").checked;
        updateRot = document.getElementById("rotationCB").checked;
        updateScale = document.getElementById("scaleCB").checked;

        // Calculate updates/second
        let updatesPerSecond = document.getElementById("updatesPerSecond").value;
        updateIntervalSeconds = 1000 / updatesPerSecond;

        let docStepSize = parseFloat(document.getElementById("stepSize").value);
        if (docStepSize != stepSize) {
            looper = 0;
            stepSize = docStepSize;
        }
    }

    /** 
     * Start/End presentation
     */
    function startPresentation() {
        socket.emit('presentation_start', STATE.id);
    }

    function endPresentation() {
        socket.emit('presentation_end', STATE.id);
    }

    /** 
     * Slide Change
     */
    function slideChange() {
        let id = document.getElementById("emitSlide_changeId").value;
        console.log(id);
        document.getElementById("slideIdIndicator").innerHTML = id;
        socket.emit('slide_change', id);
    }

    // Error message functions

    function emitError(msg) {
        console.log(msg);
        document.getElementById("emitError").style.visibility = "";
        document.getElementById("errorMsg").innerHTML = msg;
    }

    function clearError() {
        document.getElementById("emitError").style.visibility = "hidden";
        document.getElementById("errorMsg").innerHTML = "";
    }

    </script>

</body>

</html>
